// This is the top syntax node
?start: top_level_stmt*

// A top level statement exists only outside of a scope
top_level_stmt: region | function_def

// A region is a specific program or circuit that can use functions from the file
region: "region" r_ident "<" uint ">" block

// Comments begin with // and are terminated at the newline character
SINGLE_COMMENT: "//" /[^\n]/*
%ignore SINGLE_COMMENT

// A function is a segment of code that is inserted inline to the program
function_def: "func" f_ident "(" arg_list? ")" block

function_call: f_ident "(" call_list ")"

call_list: expr ("," call_list)* | q_expr ("," call_list)*

// The following three terminals are identifiers for regions, functions, and variables, respectively.

r_ident: /[a-zA-Z_][a-zA-Z0-9_]*/

f_ident: /[a-zA-Z_][a-zA-Z0-9_]*/

v_ident: /[a-zA-Z_][a-zA-Z0-9_]*/

// A type identifier
type: /[a-zA-Z_][a-zA-Z0-9_]*(\[\])?/

// An unsigned integer (aka whole number)
uint: /[0-9]+/

// A list of arguments for a function
arg_list: arg ("," arg_list)*

// An argument for a function
arg: v_ident ":" type

// A block is a set of statements contained within brackets
block: "{" stmt* "}"

// A statement can either be a function call, declaration, return statement,
stmt: (function_call | declaration | q_declaration | measurement ) ";" | if

declaration: type v_ident "=" expr

q_declaration: type v_ident "=" q_lit

measurement: v_ident "<-" q_expr

expr: atomic | product | sum

if: "if" b_expr block

b_expr: eq | neq | greater | lesser

eq: expr "==" expr

neq: expr "!=" expr

greater: expr ">" expr

lesser: expr "<" expr

paren: "(" expr ")"

sum: product
     | add
     | sub

add: sum "+" product
sub: sum "-" product

product: atomic | mul | div

mul: product "*" atomic
div: product "/" atomic

atomic: uint | v_ident | "(" sum ")" -> paren

q_expr: q_slice | q_index

q_slice: v_ident "[" expr ":" expr "]"

q_index: v_ident "[" expr "]"

q_lit: "^" qubit+ "^"

qubit: ONE | ZERO

ONE: "1"

ZERO: "0"

%import common.WS
%ignore WS